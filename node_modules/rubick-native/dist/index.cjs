'use strict';

var xWin = require('@miniben90/x-win');
var promises = require('fs/promises');
var os = require('os');
var path = require('path');
var fdir = require('fdir');

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/.pnpm/tsup@8.0.1_typescript@5.3.2/node_modules/tsup/assets/cjs_shims.js
var init_cjs_shims = __esm({
  "node_modules/.pnpm/tsup@8.0.1_typescript@5.3.2/node_modules/tsup/assets/cjs_shims.js"() {
  }
});

// addon/index.js
var require_addon = __commonJS({
  "addon/index.js"(exports, module) {
    init_cjs_shims();
    var nativeBinding = new Function(`require`, `__dirname`, `// prettier-ignore
/* eslint-disable */
/* auto-generated by NAPI-RS */

const { existsSync, readFileSync } = require('fs')
const { join } = require('path')

const { platform, arch } = process

let nativeBinding = null
let localFileExisted = false
let loadError = null

const isMusl = () => {
  let musl = false
  if (process.platform === 'linux') {
    musl = isMuslFromFilesystem()
    if (musl === null) {
      musl = isMuslFromReport()
    }
    if (musl === null) {
      musl = isMuslFromChildProcess()
    }
  }
  return musl
}

const isFileMusl = (f) => f.includes('libc.musl-') || f.includes('ld-musl-')

const isMuslFromFilesystem = () => {
  try {
    return readFileSync('/usr/bin/ldd', 'utf-8').includes('musl')
  } catch {
    return null
  }
}

const isMuslFromReport = () => {
  const report = typeof process.report.getReport === 'function' ? process.report.getReport() : null
  if (!report) {
    return null
  }
  if (report.header && report.header.glibcVersionRuntime) {
    return false
  }
  if (Array.isArray(report.sharedObjects)) {
    if (report.sharedObjects.some(isFileMusl)) {
      return true
    }
  }
  return false
}

const isMuslFromChildProcess = () => {
  try {
    return require('child_process').execSync('ldd --version', { encoding: 'utf8' }).includes('musl')
  } catch (e) {
    // If we reach this case, we don't know if the system is musl or not, so is better to just fallback to false
    return false
  }
}

switch (platform) {
  case 'android':
    switch (arch) {
      case 'arm64':
        localFileExisted = existsSync(join(__dirname, 'rubick-native-addon.android-arm64.node'))
        try {
          if (localFileExisted) {
            nativeBinding = require('./rubick-native-addon.android-arm64.node')
          } else {
            nativeBinding = require('rubick-native-addon-android-arm64')
          }
        } catch (e) {
          loadError = e
        }
        break
      case 'arm':
        localFileExisted = existsSync(join(__dirname, 'rubick-native-addon.android-arm-eabi.node'))
        try {
          if (localFileExisted) {
            nativeBinding = require('./rubick-native-addon.android-arm-eabi.node')
          } else {
            nativeBinding = require('rubick-native-addon-android-arm-eabi')
          }
        } catch (e) {
          loadError = e
        }
        break
      default:
        throw new Error(\`Unsupported architecture on Android \${arch}\`)
    }
    break
  case 'win32':
    switch (arch) {
      case 'x64':
        localFileExisted = existsSync(
          join(__dirname, 'rubick-native-addon.win32-x64-msvc.node')
        )
        try {
          if (localFileExisted) {
            nativeBinding = require('./rubick-native-addon.win32-x64-msvc.node')
          } else {
            nativeBinding = require('rubick-native-addon-win32-x64-msvc')
          }
        } catch (e) {
          loadError = e
        }
        break
      case 'ia32':
        localFileExisted = existsSync(
          join(__dirname, 'rubick-native-addon.win32-ia32-msvc.node')
        )
        try {
          if (localFileExisted) {
            nativeBinding = require('./rubick-native-addon.win32-ia32-msvc.node')
          } else {
            nativeBinding = require('rubick-native-addon-win32-ia32-msvc')
          }
        } catch (e) {
          loadError = e
        }
        break
      case 'arm64':
        localFileExisted = existsSync(
          join(__dirname, 'rubick-native-addon.win32-arm64-msvc.node')
        )
        try {
          if (localFileExisted) {
            nativeBinding = require('./rubick-native-addon.win32-arm64-msvc.node')
          } else {
            nativeBinding = require('rubick-native-addon-win32-arm64-msvc')
          }
        } catch (e) {
          loadError = e
        }
        break
      default:
        throw new Error(\`Unsupported architecture on Windows: \${arch}\`)
    }
    break
  case 'darwin':
    localFileExisted = existsSync(join(__dirname, 'rubick-native-addon.darwin-universal.node'))
    try {
      if (localFileExisted) {
        nativeBinding = require('./rubick-native-addon.darwin-universal.node')
      } else {
        nativeBinding = require('rubick-native-addon-darwin-universal')
      }
      break
    } catch {}
    switch (arch) {
      case 'x64':
        localFileExisted = existsSync(join(__dirname, 'rubick-native-addon.darwin-x64.node'))
        try {
          if (localFileExisted) {
            nativeBinding = require('./rubick-native-addon.darwin-x64.node')
          } else {
            nativeBinding = require('rubick-native-addon-darwin-x64')
          }
        } catch (e) {
          loadError = e
        }
        break
      case 'arm64':
        localFileExisted = existsSync(
          join(__dirname, 'rubick-native-addon.darwin-arm64.node')
        )
        try {
          if (localFileExisted) {
            nativeBinding = require('./rubick-native-addon.darwin-arm64.node')
          } else {
            nativeBinding = require('rubick-native-addon-darwin-arm64')
          }
        } catch (e) {
          loadError = e
        }
        break
      default:
        throw new Error(\`Unsupported architecture on macOS: \${arch}\`)
    }
    break
  case 'freebsd':
    if (arch !== 'x64') {
      throw new Error(\`Unsupported architecture on FreeBSD: \${arch}\`)
    }
    localFileExisted = existsSync(join(__dirname, 'rubick-native-addon.freebsd-x64.node'))
    try {
      if (localFileExisted) {
        nativeBinding = require('./rubick-native-addon.freebsd-x64.node')
      } else {
        nativeBinding = require('rubick-native-addon-freebsd-x64')
      }
    } catch (e) {
      loadError = e
    }
    break
  case 'linux':
    switch (arch) {
      case 'x64':
        if (isMusl()) {
          localFileExisted = existsSync(
            join(__dirname, 'rubick-native-addon.linux-x64-musl.node')
          )
          try {
            if (localFileExisted) {
              nativeBinding = require('./rubick-native-addon.linux-x64-musl.node')
            } else {
              nativeBinding = require('rubick-native-addon-linux-x64-musl')
            }
          } catch (e) {
            loadError = e
          }
        } else {
          localFileExisted = existsSync(
            join(__dirname, 'rubick-native-addon.linux-x64-gnu.node')
          )
          try {
            if (localFileExisted) {
              nativeBinding = require('./rubick-native-addon.linux-x64-gnu.node')
            } else {
              nativeBinding = require('rubick-native-addon-linux-x64-gnu')
            }
          } catch (e) {
            loadError = e
          }
        }
        break
      case 'arm64':
        if (isMusl()) {
          localFileExisted = existsSync(
            join(__dirname, 'rubick-native-addon.linux-arm64-musl.node')
          )
          try {
            if (localFileExisted) {
              nativeBinding = require('./rubick-native-addon.linux-arm64-musl.node')
            } else {
              nativeBinding = require('rubick-native-addon-linux-arm64-musl')
            }
          } catch (e) {
            loadError = e
          }
        } else {
          localFileExisted = existsSync(
            join(__dirname, 'rubick-native-addon.linux-arm64-gnu.node')
          )
          try {
            if (localFileExisted) {
              nativeBinding = require('./rubick-native-addon.linux-arm64-gnu.node')
            } else {
              nativeBinding = require('rubick-native-addon-linux-arm64-gnu')
            }
          } catch (e) {
            loadError = e
          }
        }
        break
      case 'arm':
        localFileExisted = existsSync(
          join(__dirname, 'rubick-native-addon.linux-arm-gnueabihf.node')
        )
        try {
          if (localFileExisted) {
            nativeBinding = require('./rubick-native-addon.linux-arm-gnueabihf.node')
          } else {
            nativeBinding = require('rubick-native-addon-linux-arm-gnueabihf')
          }
        } catch (e) {
          loadError = e
        }
        break
      default:
        throw new Error(\`Unsupported architecture on Linux: \${arch}\`)
    }
    break
  default:
    throw new Error(\`Unsupported OS: \${platform}, architecture: \${arch}\`)
}

if (!nativeBinding) {
  if (loadError) {
    throw loadError
  }
  throw new Error(\`Failed to load native binding\`)
}
return nativeBinding`)(__require, __dirname);
    module.exports.LnkData = nativeBinding.LnkData;
    module.exports.ShorCutImg = nativeBinding.ShorCutImg;
    module.exports.exeLookBase64 = nativeBinding.exeLookBase64;
    module.exports.getClipboardContent = nativeBinding.getClipboardContent;
    module.exports.grabInputEvent = nativeBinding.grabInputEvent;
    module.exports.MouseAction = nativeBinding.MouseAction;
    module.exports.MouseBtn = nativeBinding.MouseBtn;
    module.exports.onInputEvent = nativeBinding.onInputEvent;
    module.exports.parseLnk = nativeBinding.parseLnk;
    module.exports.sendKeyboardSimulation = nativeBinding.sendKeyboardSimulation;
    module.exports.sendMouseSimulation = nativeBinding.sendMouseSimulation;
  }
});

// src/index.ts
init_cjs_shims();

// src/clipboard.ts
init_cjs_shims();
var import_addon = __toESM(require_addon(), 1);
var getClipboardContent = () => {
  const c = (0, import_addon.getClipboardContent)();
  if (c?.type === "text") {
    return {
      type: "text",
      content: c.content.at(0)
    };
  } else {
    return c;
  }
};

// src/folder.ts
init_cjs_shims();
var getFolderOpenPath = async () => {
  if (process.platform === "darwin") {
    const { execa } = await import('execa');
    const res = await execa("osascript", ["-e", `
			tell app "Finder"
				try
					POSIX path of (insertion location as alias)
				on error
					POSIX path of (path to desktop folder as alias)
				end try
			end tell
		`]);
    return res.stdout;
  }
  if (process.platform === "win32") {
    const win = xWin.activeWindow();
    if (win.info.execName === "explorer") {
      const base = os.homedir();
      let path$1;
      switch (win.title) {
        case "Home":
        case "\u4E3B\u6587\u4EF6\u5939":
          path$1 = base;
          break;
        case "Downloads":
        case "\u4E0B\u8F7D":
          path$1 = path.join(base, "Downloads");
          break;
        case "Documents":
        case "\u6587\u6863":
          path$1 = path.join(base, "Documents");
          break;
        case "Desktop":
        case "\u684C\u9762":
          path$1 = path.join(base, "Desktop");
          break;
        case "Videos":
        case "\u89C6\u9891":
          path$1 = path.join(base, "Videos");
          break;
        case "Pictures":
        case "\u56FE\u7247":
          path$1 = path.join(base, "Pictures");
          break;
        case "Music":
        case "\u97F3\u4E50":
          path$1 = path.join(base, "Music");
          break;
        case "Links":
        case "\u94FE\u63A5":
          path$1 = path.join(base, "Music");
          break;
        default:
          path$1 = win.title;
          break;
      }
      try {
        const s = await promises.lstat(path$1);
        if (s.isDirectory()) {
          return path$1;
        }
      } catch {
        return null;
      }
    }
  }
  return null;
};

// src/simulation.ts
init_cjs_shims();
var import_addon2 = __toESM(require_addon(), 1);
var sendKeyboardSimulation = (cmd) => (0, import_addon2.sendKeyboardSimulation)(cmd);
var mouseScrollX = (len) => {
  (0, import_addon2.sendMouseSimulation)({ action: 3, data: { x: len, y: 0 } });
};
var mouseScrollY = (len) => {
  (0, import_addon2.sendMouseSimulation)({ action: 4, data: { x: 0, y: len } });
};
var mouseMove = (input) => {
  (0, import_addon2.sendMouseSimulation)({ action: input.type === "absolute" ? 2 : 1, data: input.data });
};
var mouseLocaion = () => (0, import_addon2.sendMouseSimulation)({ action: 0 });
var mouseDUC = (btn, action) => {
  let button = 0;
  switch (btn) {
    case "Left":
      break;
    case "Middle":
      button = 1;
      break;
    case "Right":
      button = 2;
      break;
    case "Back":
      button = 3;
      break;
    case "Forward":
      button = 4;
      break;
  }
  (0, import_addon2.sendMouseSimulation)({ action, button });
};
var mouseDown = (btn) => mouseDUC(btn, 6);
var mouseUp = (btn) => mouseDUC(btn, 5);
var mouseClick = (btn) => mouseDUC(btn, 7);

// src/monitor.ts
init_cjs_shims();
var import_addon3 = __toESM(require_addon(), 1);
var parse = (e) => {
  const event = JSON.parse(e);
  const [type, value] = Object.entries(event.event_type).pop();
  return {
    time: event.time,
    name: event.name,
    event: { type, value }
  };
};
var onInputEvent = (callback) => (0, import_addon3.onInputEvent)((event) => callback(parse(event)));
var grabInputEvent = (callback) => (0, import_addon3.grabInputEvent)((event) => callback(parse(event)));

// src/sysapp/index.ts
init_cjs_shims();

// src/sysapp/windows.ts
init_cjs_shims();
var import_addon4 = __toESM(require_addon(), 1);
var shortcutWin = async (callback, extraPath = []) => {
  const hdir = os.homedir();
  const f = new fdir.fdir().glob("./**/*.lnk").withFullPaths().filter((t) => {
    const d = (0, import_addon4.parseLnk)(t);
    callback({
      ...path.parse(t),
      description: d.nameString,
      execPath: d.fullPath,
      shortCutPath: t,
      workingDir: d.workingDir
    });
    return true;
  });
  const defaultPaths = [
    path.join(process.env.ProgramData, "/Microsoft/Windows/Start Menu/Programs"),
    path.join(process.env.AppData, "/Microsoft/Windows/Start Menu/Programs"),
    path.join(process.env.PUBLIC, "Desktop"),
    path.join(hdir, "Desktop"),
    ...extraPath
  ];
  await Promise.allSettled(defaultPaths.map((path) => f.crawl(path).withPromise()));
};

// src/sysapp/index.ts
var import_addon5 = __toESM(require_addon(), 1);
var getSystemApp = async (callback, extraPath) => {
  switch (os.platform()) {
    case "win32":
      return await shortcutWin(callback, extraPath);
    default:
      throw new Error("Your System is Not Supported");
  }
};
var getAppIcon = (path) => {
  switch (os.platform()) {
    case "win32":
      return (0, import_addon5.exeLookBase64)(path);
    default:
      throw new Error("Your System is Not Supported");
  }
};

Object.defineProperty(exports, 'getActiveWin', {
  enumerable: true,
  get: function () { return xWin.activeWindow; }
});
Object.defineProperty(exports, 'getOpenWin', {
  enumerable: true,
  get: function () { return xWin.openWindows; }
});
exports.getAppIcon = getAppIcon;
exports.getClipboardContent = getClipboardContent;
exports.getFolderOpenPath = getFolderOpenPath;
exports.getSystemApp = getSystemApp;
exports.grabInputEvent = grabInputEvent;
exports.mouseClick = mouseClick;
exports.mouseDown = mouseDown;
exports.mouseLocaion = mouseLocaion;
exports.mouseMove = mouseMove;
exports.mouseScrollX = mouseScrollX;
exports.mouseScrollY = mouseScrollY;
exports.mouseUp = mouseUp;
exports.onInputEvent = onInputEvent;
exports.sendKeyboardSimulation = sendKeyboardSimulation;
